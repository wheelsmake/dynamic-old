{"version":3,"file":"dynamic.min.js","mappings":"mBAKO,SAASA,EAAEC,EAAWC,GACtBA,IAAUC,WAAeD,aAAiBE,UAAUF,EAAQG,UAC3D,IAAIC,EAAcJ,EAAMK,iBAAiBN,GACzC,OAAIK,EAAEE,OAES,GAAZF,EAAEE,QAAeP,EAAEQ,MAAM,eAAuBH,EAAE,GACzCI,MAAMC,KAAKL,GAHF,GCetB,SAASM,EAAWC,EAAUC,GACjC,OAA2B,IAAxBA,EAAMC,QAAQF,GAAoB,KAC9BC,EAAME,OAAOF,EAAMC,QAAQF,GAAM,GAAG,GAOxC,SAASI,EAAEC,EAAkBC,EAAeC,EAAaC,GAC5D,MAAGH,IAAaf,UAAiB,IAAImB,MAAM,qBAGjC,IAAIA,MAAM,aAAaJ,MAAaC,EAAO,mBAAmBA,IAAS,eAAeE,EAAS,aAAaA,IAAW,KAAKD,EAAQ,SAASA,IAAU,OAG9J,SAASG,EAAGC,GAAqB,MAAM,IAAIF,MAAME,GCUxD,SAASC,EAAUN,EAAuBO,GAGtC,MAAMpB,EAAI,OAAQqB,EAAI,eAAgBC,EAAI,cAE1C,GAAK,SAAUF,EAKV,GAAG,YAAaA,GAA+B,iBAAhBA,EAAKG,QAAqB,EAAgBvB,EAAGqB,EAAGD,EAAM,eAAeE,UACpG,OAAOT,GACR,IAAK,IAEI,UAAWO,GAA8B,mBAAdA,EAAKI,SAE3B,cAAeJ,IAAkC,iBAAlBA,EAAKK,WAAyBL,EAAKK,UAAY,IAAG,EAAgBzB,EAAG,IAAIqB,IAAKD,EAAM,iBAAiBE,KAFpF,EAAgBtB,EAAG,IAAIqB,IAAKD,EAAM,aAAaE,KAGzG,MACJ,IAAK,IAGE,cAAeF,IAAkC,iBAAlBA,EAAKK,WAAyBL,EAAKK,UAAY,IAAI,EAAgBzB,EAAG,IAAIqB,IAAKD,EAAM,iBAAiBE,KACxI,MACJ,IAAK,IAEI,WAAYF,GAA+B,mBAAfA,EAAKM,WAAsB,EAAgB1B,EAAG,IAAIqB,IAAKD,EAAM,cAAcE,KAC5G,MACJ,QAEI,EAAiB,UAxBH,EAAgBtB,EAAGqB,EAAGD,EAAM,YAAYE,KCjD3D,SAASK,EACZC,EACAC,EAAmBC,GAEnB,MAAMC,EAAqBC,EAAcJ,EAAME,IAEP,GAArCF,EAAK,GAAGnB,QAAQsB,GAAwB,EAAiB,0CAGJ,GAAhDF,EAAUI,MAAMxB,QAAQsB,GAA2B,EAAgB,SAAUlC,UAAWiC,EAAQ,0BAEpGD,EAAUI,MAAMC,KAAKH,GACpBA,EAAoBI,MAAMD,KAAKL,IAGjC,SAASO,EACZR,EACAC,EAAmBC,GAEnB,MAAMC,EAAqBC,EAAcJ,EAAME,IAEP,GAArCF,EAAK,GAAGnB,QAAQsB,GAAwB,EAAiB,qEAEJ,GAAhDF,EAAUI,MAAMxB,QAAQsB,GAA2B,EAAgB,SAAUlC,UAAWiC,EAAQ,iCAEpG,EAAyBC,EAAoBF,EAAUI,OACvD,EAAyBJ,EAAYE,EAAoBI,QAe1D,SAASE,EACZT,EACAC,EAAmBC,GAEQE,EAAcJ,EAAME,GAC/C,OAAO,EAEJ,SAASQ,EACZV,EACAC,EAAmBC,GAEQE,EAAcJ,EAAME,GAC/C,OAAO,EAIX,SAASE,EAAcJ,EAAuDE,GAC1E,GAAoB,iBAAVA,EAAmB,CACzB,IAA+B,GAA5BF,EAAK,GAAGnB,QAAQqB,GAAe,OAAOA,EACpC,EAAgB,SAAUjC,UAAWiC,EAAQ,kCAEjD,GAAoB,iBAAVA,EAAmB,CAC9B,IAAI,IAAIS,EAAI,EAAGA,EAAIX,EAAK,GAAG1B,OAAQqC,IAAK,GAAGX,EAAK,GAAGW,GAAGC,OAASV,EAAQ,OAAOF,EAAK,GAAGW,GACtF,EAAgB,SAAU1C,UAAWiC,EAAQ,kCAE5C,EAAgB,SAAU,kBAAmBA,G,gwBC7DtD,MAAMW,EAAM,QAASC,SAAwC,IAA7BA,OAAqBD,IAE/C9C,EAAI,CACN,4BACA,wBACA,2BAIJ,MAAMgD,EAMFC,YAAYC,G,YALZ,mBACA,WAAyB,IACzB,WAAuB,IACvB,WAAyB,IACzB,WAAmB,IAEf,EAAAC,KAAI,ECpBL,SAAyBC,GAC5B,GAAGA,aAAiBjD,QAAS,OAAOiD,EAC/B,GAAmB,iBAATA,EAAkB,CAC7B,MAAMC,EAAK,EAAgBD,GAC3B,GAAGC,aAAcC,KAAM,OAAOD,EACzB,EAAgB,WAAY,mBAAoBD,EAAO,gDAE3D,EAAgB,WAAY,mBAAoBA,EAAO,mDDavC,CAAgCF,GAAU,KAC3D,EAAAC,KAAI,SAAU,KAAdA,KAAe,EAAAA,KAAI,QAInBD,eAAW,OAAO,EAAAC,KAAI,OAC1BI,4BACI,OAAGT,EAAW,CACVI,SAAU,EAAAC,KAAI,OACdK,UAAW,EAAAL,KAAI,OACfM,SAAU,EAAAN,KAAI,OACdO,UAAW,EAAAP,KAAI,OACfQ,IAAK,EAAAR,KAAI,QAEDnD,EAAE,GAElB4D,SAASnC,GACL,MAAMkC,EAAM,EAAAR,KAAI,OAAOK,EAAY,EAAAL,KAAI,OAAaM,EAAW,EAAAN,KAAI,OAAYO,EAAY,EAAAP,KAAI,OAC/F,IAAIU,EAEJ,GAAkB,iBAARpC,EAAiB,CAEvB,MAAMqC,EF1CX,SAAmBrC,GAEtB,OADAD,EAAU,IAAKC,GACT,CACFoB,KAAMpB,EAAKoB,KACXjB,QAAS,YAAaH,EAAOA,EAAKG,QAAW,GAC7CC,MAAOJ,EAAKI,MACZV,MAAOjB,UACP4B,UAAWL,EAAKK,UAChBQ,MAAO,IEkCY,CAA8Bb,GAC7C+B,EAAUjB,KAAKuB,GACfH,EAAIpB,KAAKuB,GACTD,EAASC,MAGT,CACA,IAAI,IAAIlB,EAAI,EAAGA,EAAIY,EAAUjD,OAAQqC,IAAQY,EAAUZ,GAAGC,OAASpB,IAAMoC,EAASL,EAAUZ,IAEzFiB,IAAY3D,WAAW,EAAgB,OAAQ,IAAIF,EAAE,KAAMyB,EAAMzB,EAAE,IAE1E,MAAM,CACFgC,UAAUG,GAAsC,EAAyB,CAACwB,EAAKH,EAAWC,EAAUC,GAAYG,EAAQ1B,GACxHM,aAAaN,GAAsC,EAA4B,CAACwB,EAAKH,EAAWC,EAAUC,GAAYG,EAAQ1B,GAC9HQ,WAAWR,GAAyC,EAA0B,CAACwB,EAAKH,EAAWC,EAAUC,GAAYG,EAAQ1B,GACzHL,gBAAY,OAAO+B,EAAO/B,WAC1BA,cAAUiC,GACQ,iBAARA,EAAkB,EAAgB,YAAa,SAAUA,GAC9DF,EAAO/B,UAAYiC,GAExB5C,YACA,OAAG2B,EAAYe,EAAO1C,MACVnB,EAAE,KAI1BgE,QAAQvC,GACJ,MAAMkC,EAAM,EAAAR,KAAI,OAAOK,EAAY,EAAAL,KAAI,OAAaM,EAAW,EAAAN,KAAI,OAAYO,EAAY,EAAAP,KAAI,OAC/F,IAAIU,EAEJ,GAAkB,iBAARpC,EAAiB,CAEvB,MAAMqC,EF9DX,SAAmBrC,GACtBD,EAAU,IAAKC,GACf,MAAMqC,EAAoB,GAgB1B,OAfAA,EAAOjB,KAAOpB,EAAKoB,KACnBiB,EAAOlC,QAAU,YAAaH,EAAOA,EAAKG,QAAW,GAElD,cAAeH,IAAMqC,EAAOhC,UAAYL,EAAKK,WAE9BgC,EAAOG,IAAtB,QAASxC,EAAmBA,EAAKwC,IAClB,WACd,OAAOd,KAAKhC,OAEE2C,EAAOI,IAAtB,QAASzC,EAAmBA,EAAKyC,IAClB,SAASjC,GACvBkB,KAAKhC,MAAQc,GAEjB6B,EAAOtB,MAAQ,GACfsB,EAAOxB,MAAQ,GACPwB,EE4Ce,CAA8BrC,GAC7CgC,EAASlB,KAAKuB,GACdH,EAAIpB,KAAKuB,GACTD,EAASC,MAGT,CACA,IAAI,IAAIlB,EAAI,EAAGA,EAAIa,EAASlD,OAAQqC,IAAQa,EAASb,GAAGC,OAASpB,IAAMoC,EAASJ,EAASb,IACtFiB,IAAY3D,WAAW,EAAgB,OAAQ,IAAIF,EAAE,KAAMyB,EAAMzB,EAAE,IAG1E,MAAMmE,EAAqB,CACvBnC,UAAUG,GAAsC,EAAyB,CAACwB,EAAKH,EAAWC,EAAUC,GAAYG,EAAQ1B,GACxHM,aAAaN,GAAsC,EAA4B,CAACwB,EAAKH,EAAWC,EAAUC,GAAYG,EAAQ1B,GAC9HiC,YAAYjC,KACZkC,eAAelC,KACfO,WAAWP,GAAyC,EAA0B,CAACwB,EAAKH,EAAWC,EAAUC,GAAYG,EAAQ1B,GAC7HQ,WAAWR,GAAyC,EAA0B,CAACwB,EAAKH,EAAWC,EAAUC,GAAYG,EAAQ1B,IAEjI,MAAG,cAAe0B,GAIdS,OAAOC,eAAeV,EAAQ,YAAa,CACvCW,cAAc,EACdC,YAAY,EACZR,IAAG,IAAWJ,EAAyB/B,UACvCoC,IAAIH,GACkB,iBAARA,EAAkB,EAAgB,YAAa,SAAUA,GAC7DF,EAAyB/B,UAAYiC,KAGnDO,OAAOC,eAAeV,EAAQ,QAAS,CACnCW,cAAc,EACdC,YAAY,EACZR,IAAG,IAAWJ,EAAyB1C,QAEpCgD,GAECA,EAEhBO,SAASjD,GACL,MAAMkC,EAAM,EAAAR,KAAI,OAAOK,EAAY,EAAAL,KAAI,OAAaM,EAAW,EAAAN,KAAI,OAAYO,EAAY,EAAAP,KAAI,OAC/F,IAAIU,EAEJ,GAAkB,iBAARpC,EAAiB,CAEvB,MAAMqC,EFxFX,SAAmBrC,GAEtB,OADAD,EAAU,IAAKC,GACT,CACFoB,KAAMpB,EAAKoB,KACXjB,QAAS,YAAaH,EAAOA,EAAKG,QAAW,GAC7CG,SAAQN,EAAKM,UACbS,MAAO,IEkFY,CAA8Bf,GAC7CiC,EAAUnB,KAAKuB,GACfH,EAAIpB,KAAKuB,GACTD,EAASC,MAGT,CACA,IAAI,IAAIlB,EAAI,EAAGA,EAAIc,EAAUnD,OAAQqC,IAAQc,EAAUd,GAAGC,OAASpB,IAAMoC,EAASH,EAAUd,IACzFiB,IAAY3D,WAAW,EAAgB,OAAQ,IAAIF,EAAE,KAAMyB,EAAMzB,EAAE,IAE1E,MAAM,CACFoE,YAAYjC,KACZkC,eAAelC,KACfO,WAAWP,GAAyC,EAA0B,CAACwB,EAAKH,EAAWC,EAAUC,GAAYG,EAAQ1B,K,+FAG3HwC,GACN,GAAGA,EAAKC,YAAY,CACHD,EAAKC,YAAYpE,MAAM,eACvBmE,EAAKC,YAAYpE,MAAM,eADpC,MAEMqE,EAAOF,EAAKC,YAAYpE,MAAM,eAEjCqE,GAAM1B,KAAKuB,SAAS,CACnB7B,KAAMgC,EAAK,GAAGC,UAAU,EAAGD,EAAK,GAAGtE,OAAS,GAC5CqB,QAAS,GACTG,SAAOE,GACH0C,EAAKC,YAAcN,OAAOS,UAAUC,SAASC,KAAM9B,KAAmBhC,UAUlF,MAAM+D,EAAQP,EAAKQ,WAGnB,IAAI,IAAIvC,EAAI,EAAGA,EAAIsC,EAAM3E,OAAQqC,KAKjC,IAAI,IAAIA,EAAI,EAAGA,EAAI+B,EAAKS,WAAW7E,OAAQqC,OH/I5C,SAASyC,EAAYC,GACxBhB,OAAOiB,OAAOD,GACd,IAAI,IAAI1C,EAAI,EAAGA,EAAI0B,OAAOkB,KAAKF,GAAK/E,OAAQqC,IAA2C,iBAA5B0C,EAAIhB,OAAOkB,KAAKF,GAAK1C,KAAiByC,EAAYC,EAAIhB,OAAOkB,KAAKF,GAAK1C,KGqJtI,CAA0BI,GAC1B,UE9KAsB,OAAOC,eAAexB,OAAQ,UAAW,CACrCyB,cAAc,EACdiB,UAAU,EACVhB,YAAY,EACZtD,MAAO,K","sources":["webpack:///../utils/element.ts","webpack:///../utils/generic.ts","webpack:///./src/utils/createDN.ts","webpack:///./src/utils/dno.ts","webpack:///./src/dynamic.ts","webpack:///../utils/arguments.ts","webpack:///./src/dynamic.export.ts"],"sourcesContent":["/* utils\r\n * ©2022 LJM12914. https://github.com/wheelsmake/utils\r\n * Licensed under MIT License. https://github.com/wheelsmake/utils/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"./index\";\r\nexport function e(s :string, scope? :Element | Document) :Node[] | Node{\r\n    if(scope === undefined || !(scope instanceof Element)) scope = document;\r\n        let a :NodeList = scope.querySelectorAll(s);\r\n        if(!a.length) return [];\r\n        //note:当一个页面存在相同ID元素时不会走这里，而会返回数组，因为说好了是querySelectorAll了并且本来就不应该有重复ID，不能怪我啊\r\n        if(a.length == 1 && s.match(/^.*#[^\\s]*$/)) return a[0];\r\n        else return Array.from(a);\r\n}\r\nexport function isDescendant(possibleDescendant :Element, possibleParent :Element) :boolean{\r\n    while(possibleDescendant.tagName != \"HTML\"){\r\n        possibleDescendant = possibleDescendant.parentNode! as Element;\r\n        if(possibleDescendant === possibleParent) return true; \r\n    }\r\n    return false;\r\n}\r\nexport function isInDocument(element :Element) :boolean{\r\n    return isDescendant(element, (e(\"html\") as Node[])[0] as Element);\r\n}\r\nexport function isChild(element :Element, target :Element) :boolean{\r\n    const children = target.childNodes;\r\n    for(let i = 0; i < children.length; i++) if(element === children[i]) return true;\r\n    return false;\r\n}\r\nexport function toHTML(HTML :string) :Node[]{\r\n    if(HTML === \"\" || typeof HTML != \"string\") utils.generic.E(\"HTML\", \"string\", HTML);\r\n    const ele = document.createElement(\"div\");\r\n    ele.innerHTML = HTML;\r\n    return getInnerNodes(ele);\r\n}\r\nexport function getInnerNodes(el :Node | Element) :Node[]{\r\n    var nodes :Node[] = [];\r\n    for(let i = 0; i < el.childNodes.length; i++) nodes[i] = el.childNodes[i].cloneNode(true);\r\n    return nodes;\r\n}\r\n//剥壳器\r\nexport function hatch(element :Element, remove? :boolean) :Node[]{\r\n    //note:Nodelist类型会实时同步造成不稳定的for循环，必须转换为Node[]！\r\n    const par = element.parentElement!, children :Node[] = Array.from(element.childNodes);\r\n    for(let i = 0; i < children.length; i++) par.insertBefore(children[i], element);\r\n    if(remove === true) element.remove();\r\n    return children;\r\n}\r\n//fixme:这个方法特异性太强了吧，能不能不要放在这里？\r\n//最终渲染方法，老祖宗求你别出bug\r\nexport function render(HTML :string | Element | HTMLCollection | Element[] | Node | NodeList | Node[], element :Element, insertAfter? :boolean, append? :boolean, disableDF? :boolean) :Node[]{\r\n    if(element.parentElement === null) utils.generic.EE(\"cannot render by '<html>' element, since it's root of document.\");\r\n    var html :Node[] = [];\r\n    if(typeof HTML == \"string\") html = toHTML(HTML);\r\n    else if(HTML instanceof Element || HTML instanceof Node) html[0] = HTML.cloneNode(true);\r\n    else if(HTML instanceof HTMLCollection || HTML instanceof NodeList) for(let i = 0; i < HTML.length; i++) html[i] = HTML.item(i)!.cloneNode(true);\r\n    else html = HTML;\r\n    const Rhtml = [...html].reverse(), parent = element.parentElement;\r\n    if(append === true) for(let i = 0; i < html.length; i++) element.append(html[i]);\r\n    else if(append === false) for(let i = 0; i < Rhtml.length; i++) element.prepend(Rhtml[i]);\r\n    else if(insertAfter === true){\r\n        if(!element.nextSibling) for(let i = 0; i < Rhtml.length; i++) parent!.append(Rhtml[i]);\r\n        else for(let i = 0; i < Rhtml.length; i++) parent!.insertBefore(Rhtml[i], element.nextSibling);\r\n    }\r\n    else if(insertAfter === false) for(let i = 0; i < html.length; i++) parent!.insertBefore(html[i], element);\r\n    else for(let i = 0; i < html.length; i++) element.append(html[i]);\r\n    //todo:加入作用域\r\n    return html;\r\n}","/* utils\r\n * ©2022 LJM12914. https://github.com/wheelsmake/utils\r\n * Licensed under MIT License. https://github.com/wheelsmake/utils/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"./index\";\r\nexport function randoma2Z(length :number) :string{ //52\r\n    var s :string = \"\";\r\n    for(let i = 0; i < length; i++){\r\n        let r = Math.floor(Math.random() * 52);\r\n        if(r > 25) s += String.fromCharCode(r + 71);\r\n        else s += String.fromCharCode(r + 65);\r\n    }\r\n    return s;\r\n}\r\nexport function randoma2z029(length :number) :string{ //36\r\n    var s :string = \"\";\r\n    for(let i = 0; i < length; i++){\r\n        let r = Math.floor(Math.random() * 36);\r\n        if(r < 10) s += r;\r\n        else s += String.fromCharCode(r + 87);\r\n    }\r\n    return s;\r\n}\r\nexport function precisePop(ele :any, array :any[]) :any | null{\r\n    if(array.indexOf(ele) === -1) return null;\r\n    return array.splice(array.indexOf(ele), 1)[0];\r\n}\r\n//递归冻结对象\r\nexport function constantize(obj :anyObject) :void{\r\n    Object.freeze(obj);\r\n    for(let i = 0; i < Object.keys(obj).length; i++) if(typeof obj[Object.keys(obj)[i]] == \"object\") constantize(obj[Object.keys(obj)[i]]);\r\n}\r\nexport function E(argument :string, type? :string, value? :any, reason? :string) :never{\r\n    if(argument === undefined) throw new Error(\"An error occured.\");\r\n    else{\r\n        console.info(\"ERROR INFO: argument\", argument, \",type\", type, \",value\", value, \",reason\", reason); //为了拿到真正的value，其他类型toString后啥信息都没了\r\n        throw new Error(`Argument '${argument}' ${type ? `should be a(an) ${type}` : \"is invalid\"}${reason ? `, reason: ${reason}` : \"\"}${value ? `, got ${value}` : \"\"}.`);\r\n    }\r\n}\r\nexport function EE(message :any) :never{throw new Error(message);}\r\nexport function repeat(item :any, count :number) :any[]{\r\n    if(typeof count != \"number\" || count < 1) utils.generic.E(\"count\", \"number smaller than 1\", count);\r\n    var arr :any[] = [];\r\n    arr[count - 1] = \" \";\r\n    return arr.fill(item, 0, count);\r\n}","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"../../../utils/index\";\r\n/**看清我是**S**！！*/\r\nexport function createSDN(args :sDNcreateArgs) :sourceDN{\r\n    checkArgs(\"s\", args);\r\n    return{\r\n        name: args.name,\r\n        methods: \"methods\" in args ? args.methods! : {},\r\n        fetch: args.fetch,\r\n        value: undefined,\r\n        frequency: args.frequency,\r\n        nexts: []\r\n    };\r\n}\r\n/**看清我是**T**！！*/\r\nexport function createTDN(args :tDNcreateArgs) :transDN{\r\n    checkArgs(\"t\", args);\r\n    const result :anyObject = {};\r\n    result.name = args.name;\r\n    result.methods = \"methods\" in args ? args.methods! : {};\r\n    //决定是否为缓存传递节点\r\n    if(\"frequency\" in args) result.frequency = args.frequency;\r\n    //else 这里什么都不做\r\n    if(\"get\" in args) result.get = args.get;\r\n    else result.get = function() :any{\r\n        return this.value; //这里的this是精心设计好的，不会是数据节点本身\r\n    };\r\n    if(\"set\" in args) result.set = args.set;\r\n    else result.set = function(data :any) :any{\r\n        this.value = data; //同L29\r\n    }\r\n    result.prevs = [];\r\n    result.nexts = [];\r\n    return (result as transDN);\r\n}\r\n/**看清我是**E**！！*/\r\nexport function createEDN(args :eDNcreateArgs) :exportDN{\r\n    checkArgs(\"e\", args);\r\n    return{\r\n        name: args.name,\r\n        methods: \"methods\" in args ? args.methods! : {},\r\n        export: args.export,\r\n        prevs: []\r\n    };\r\n}\r\n\r\nfunction checkArgs(type :\"s\" | \"t\" | \"e\", args :any/*只能写any，否则第一个if后全是never因为ts认为第一个if一定会走，\r\n                有时候觉得ts反而增加了逻辑的难度，这是变量的验证期啊，你ts怎么知道别人传进来的一定是对的？？？？？*/) :void{\r\n    //重用字符串\r\n    const a = \"args\", b = \"DNCreateArgs\", c = \" is invalid\";\r\n    //没name\r\n    if(!(\"name\" in args)) utils.generic.E(a, b, args, `${a}.name${c}`);\r\n    //methods不符合规范（不完全验证，因为貌似没有可以不用循环判断一个对象里是否都是某类型的方法）\r\n    //没关系，methods我们不需要验证太多，等到调用的时候让开发者自己懵逼吧\r\n    //note: typeof xxx == \"type\" 是可以的，typeof运算比比较运算优先级高\r\n    //并且其实\"sth\" in obj的in运算也比比较运算优先级高\r\n    else if(\"methods\" in args && typeof args.methods != \"object\") utils.generic.E(a, b, args, `${a}.methods${c}`);\r\n    else switch(type){\r\n        case \"s\":\r\n            //fetch不对劲\r\n            if(!(\"fetch\" in args) || typeof args.fetch != \"function\") utils.generic.E(a, `s${b}`, args, `${a}.fetch${c}`);\r\n            //frequency不对劲\r\n            else if(!(\"frequency\" in args) || typeof args.frequency != \"number\" || args.frequency < 0) utils.generic.E(a, `s${b}`, args, `${a}.frequency${c}`);\r\n            break;\r\n        case \"t\":\r\n            //frequency不是数字或小于0（等于0则为常量）\r\n            //没frequency则创建普通传递节点，否则创建缓存传递节点\r\n            if(\"frequency\" in args && (typeof args.frequency != \"number\" || args.frequency < 0)) utils.generic.E(a, `t${b}`, args, `${a}.frequency${c}`);\r\n            break;\r\n        case \"e\":\r\n            //export不对劲\r\n            if(!(\"export\" in args) || typeof args.export != \"function\") utils.generic.E(a, `e${b}`, args, `${a}.export${c}`);\r\n            break;\r\n        default:\r\n            //绝不会走到这里\r\n            utils.generic.EE(\"?\");\r\n            break;\r\n    }\r\n}","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"../../../utils/index\";\r\nexport function connectTo(\r\n    data :[dataNode[], sourceDN[], transDN[], exportDN[]],\r\n    objective :prevDN, target :string | nextDN\r\n) :void{\r\n    const targetDN :dataNode = processTarget(data, target)!;\r\n    //是否是源节点，源节点不能被连接\r\n    if(data[1].indexOf(targetDN as any) != -1) utils.generic.EE(\"Source datanodes cannot be connected.\");\r\n    //是否已经连接了，重复的不要\r\n    //argument:这里是否需要双边检测？如果可能存在单边连接，则需要这样做。目前仅检测objective方。\r\n    else if(objective.nexts.indexOf(targetDN as nextDN) != -1) utils.generic.E(\"target\", undefined, target, \"duplicated next nodes\");\r\n    else{\r\n        objective.nexts.push(targetDN as nextDN);\r\n        (targetDN as nextDN).prevs.push(objective);\r\n    }\r\n}\r\nexport function disconnectTo(\r\n    data :[dataNode[], sourceDN[], transDN[], exportDN[]],\r\n    objective :prevDN, target :string | nextDN\r\n) :void{\r\n    const targetDN :dataNode = processTarget(data, target)!;\r\n    //是否是源节点\r\n    if(data[1].indexOf(targetDN as any) != -1) utils.generic.EE(\"Source datanodes cannot be connected, thus wont be disconnected.\");\r\n    //是否没有连接argument:与上面一样\r\n    else if(objective.nexts.indexOf(targetDN as nextDN) == -1) utils.generic.E(\"target\", undefined, target, \"cannot find it as next nodes\");\r\n    else{\r\n        utils.generic.precisePop(targetDN as nextDN, objective.nexts);\r\n        utils.generic.precisePop(objective, (targetDN as nextDN).prevs);\r\n    }\r\n}\r\nexport function connectFrom(\r\n    data :[dataNode[], sourceDN[], transDN[], exportDN[]],\r\n    objective :nextDN, target :string | prevDN\r\n) :void{\r\n\r\n}\r\nexport function disconnectFrom(\r\n    data :[dataNode[], sourceDN[], transDN[], exportDN[]],\r\n    objective :nextDN, target :string | prevDN\r\n) :void{\r\n\r\n}\r\nexport function existsPrev(\r\n    data :[dataNode[], sourceDN[], transDN[], exportDN[]],\r\n    objective :nextDN, target :string | prevDN\r\n) :boolean{\r\n    const targetDN :dataNode = processTarget(data, target)!;\r\n    return false;\r\n}\r\nexport function existsNext(\r\n    data :[dataNode[], sourceDN[], transDN[], exportDN[]],\r\n    objective :prevDN, target :string | nextDN\r\n) :boolean{\r\n    const targetDN :dataNode = processTarget(data, target)!;\r\n    return false;\r\n}\r\n\r\n/**void懂的*/\r\nfunction processTarget(data :[dataNode[], sourceDN[], transDN[], exportDN[]], target :string | dataNode) :dataNode | void{\r\n    if(typeof target == \"object\"){\r\n        if(data[0].indexOf(target) != -1) return target;\r\n        else utils.generic.E(\"target\", undefined, target, \"cannot find this datanode\");\r\n    }\r\n    else if(typeof target == \"string\"){\r\n        for(let i = 0; i < data[0].length; i++) if(data[0][i].name === target) return data[0][i];\r\n        utils.generic.E(\"target\", undefined, target, \"cannot find this datanode\");\r\n    }\r\n    else utils.generic.E(\"target\", \"string | nextDN\", target);\r\n}","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"../../utils/index\";\r\nimport * as localUtils from \"./utils/index\";\r\n\r\n\r\n//开发模式\r\nconsole.info(\"dynamic ©LJM12914. https://github.com/wheelsmake/dynamic \\r\\nYou are using an unminified version of dynamic, which is not suitable for production use.\");\r\nconst DEV = \"DEV\" in window && (window as anyObject).DEV === true;\r\n//重用字符串\r\nconst s = [\r\n    \"cannot find this datanode\",\r\n    \"DNcreateArgs | string\",\r\n    \"BLOCKED IN NON-DEV MODE\"\r\n];\r\n\r\n//主类\r\nclass Dynamic{\r\n    #rootNode :Element;\r\n    #sourceDNs :sourceDN[] = [];\r\n    #transDNs :transDN[] = [];\r\n    #exportDNs :exportDN[] = [];\r\n    #DNs :dataNode[] = [];\r\n    constructor(rootNode :Elementy){\r\n        this.#rootNode = utils.arguments.reduceToElement(rootNode)!;\r\n        this.#detectDN(this.#rootNode);\r\n        //开发模式记录\r\n        console.info(\"creating new dynamic instance with rootNode\", rootNode);\r\n    }\r\n    get rootNode(){return this.#rootNode;}\r\n    __DEV__getPrivateFields__(){\r\n        if(DEV) return{\r\n            rootNode: this.#rootNode,\r\n            sourceDNs: this.#sourceDNs,\r\n            transDNs: this.#transDNs,\r\n            exportDNs: this.#exportDNs,\r\n            DNs: this.#DNs\r\n        }\r\n        else return s[2];\r\n    }\r\n    sourceDN(args :sDNcreateArgs | string) :sDNOperations{\r\n        const DNs = this.#DNs, sourceDNs = this.#sourceDNs, transDNs = this.#transDNs, exportDNs = this.#exportDNs;\r\n        var thisDN :sourceDN;\r\n        //创建节点\r\n        if(typeof args == \"object\"){\r\n            //create会审查参数\r\n            const result = localUtils.createDN.createSDN(args)!;\r\n            sourceDNs.push(result);\r\n            DNs.push(result);\r\n            thisDN = result;\r\n        }\r\n        //查找节点\r\n        else{\r\n            for(let i = 0; i < sourceDNs.length; i++) if(sourceDNs[i].name === args) thisDN = sourceDNs[i];\r\n            //这就让我很不爽了，ts怎么会逼我写出带断言的变量等于undefined这种东西？？？\r\n            if(thisDN! === undefined) utils.generic.E(\"args\", `s${s[1]}`, args, s[0]);\r\n        }\r\n        return{\r\n            connectTo(target :string | nextDN) :void{return localUtils.dno.connectTo([DNs, sourceDNs, transDNs, exportDNs], thisDN, target);},\r\n            disconnectTo(target :string | nextDN) :void{return localUtils.dno.disconnectTo([DNs, sourceDNs, transDNs, exportDNs], thisDN, target);},\r\n            existsNext(target :string | nextDN) :boolean{return localUtils.dno.existsNext([DNs, sourceDNs, transDNs, exportDNs], thisDN, target);},\r\n            get frequency(){return thisDN.frequency;},\r\n            set frequency(freq :number){\r\n                if(typeof freq != \"number\") utils.generic.E(\"frequency\", \"number\", freq);\r\n                else thisDN.frequency = freq;\r\n            },\r\n            get value(){\r\n                if(DEV) return thisDN.value;\r\n                else return s[2];\r\n            }\r\n        }\r\n    }\r\n    transDN(args :tDNcreateArgs | string) :tDNOperations | ctDNOperations{\r\n        const DNs = this.#DNs, sourceDNs = this.#sourceDNs, transDNs = this.#transDNs, exportDNs = this.#exportDNs;\r\n        var thisDN :transDN;\r\n        //创建节点\r\n        if(typeof args == \"object\"){\r\n            //create会审查参数\r\n            const result = localUtils.createDN.createTDN(args)!;\r\n            transDNs.push(result);\r\n            DNs.push(result);\r\n            thisDN = result;\r\n        }\r\n        //查找节点\r\n        else{\r\n            for(let i = 0; i < transDNs.length; i++) if(transDNs[i].name === args) thisDN = transDNs[i];\r\n            if(thisDN! === undefined) utils.generic.E(\"args\", `t${s[1]}`, args, s[0]);\r\n        }\r\n        thisDN = thisDN!;\r\n        const result2 :anyObject = {\r\n            connectTo(target :string | nextDN) :void{return localUtils.dno.connectTo([DNs, sourceDNs, transDNs, exportDNs], thisDN, target);},\r\n            disconnectTo(target :string | nextDN) :void{return localUtils.dno.disconnectTo([DNs, sourceDNs, transDNs, exportDNs], thisDN, target);},\r\n            connectFrom(target :string | prevDN) :void{return localUtils.dno.connectFrom([DNs, sourceDNs, transDNs, exportDNs], thisDN, target);},\r\n            disconnectFrom(target :string | prevDN) :void{return localUtils.dno.disconnectFrom([DNs, sourceDNs, transDNs, exportDNs], thisDN, target);},\r\n            existsPrev(target :string | prevDN) :boolean{return localUtils.dno.existsPrev([DNs, sourceDNs, transDNs, exportDNs], thisDN, target)},\r\n            existsNext(target :string | nextDN) :boolean{return localUtils.dno.existsNext([DNs, sourceDNs, transDNs, exportDNs], thisDN, target)}\r\n        };\r\n        if(\"frequency\" in thisDN){\r\n            //判断是否为缓存传递节点（ctransitive），如果是，提供缓存访问方法\r\n            //note:如果在已存在的对象上添加getter和setter，需要使用Object.defineProperty，result2[\"get xxx\"]是没用的！\r\n            //Object.defineProperty有一大堆默认配置坑，烦死了\r\n            Object.defineProperty(thisDN, \"frequency\", {\r\n                configurable: false,\r\n                enumerable: true,\r\n                get(){return (thisDN as ctransitiveDN).frequency;},\r\n                set(freq :number){\r\n                    if(typeof freq != \"number\") utils.generic.E(\"frequency\", \"number\", freq);\r\n                    else (thisDN as ctransitiveDN).frequency = freq;\r\n                }\r\n            });\r\n            Object.defineProperty(thisDN, \"value\", {\r\n                configurable: false,\r\n                enumerable: true,\r\n                get(){return (thisDN as ctransitiveDN).value;}\r\n            });\r\n            return result2 as ctDNOperations;\r\n        }\r\n        else return result2 as tDNOperations;\r\n    }\r\n    exportDN(args :eDNcreateArgs | string) :eDNOperations{\r\n        const DNs = this.#DNs, sourceDNs = this.#sourceDNs, transDNs = this.#transDNs, exportDNs = this.#exportDNs;\r\n        var thisDN :exportDN;\r\n        //创建节点\r\n        if(typeof args == \"object\"){\r\n            //create会审查参数\r\n            const result = localUtils.createDN.createEDN(args)!;\r\n            exportDNs.push(result);\r\n            DNs.push(result);\r\n            thisDN = result;\r\n        }\r\n        //查找节点\r\n        else{\r\n            for(let i = 0; i < exportDNs.length; i++) if(exportDNs[i].name === args) thisDN = exportDNs[i];\r\n            if(thisDN! === undefined) utils.generic.E(\"args\", `e${s[1]}`, args, s[0]);\r\n        }\r\n        return{\r\n            connectFrom(target :string | prevDN) :void{return localUtils.dno.connectFrom([DNs, sourceDNs, transDNs, exportDNs], thisDN, target);},\r\n            disconnectFrom(target :string | prevDN) :void{return localUtils.dno.disconnectFrom([DNs, sourceDNs, transDNs, exportDNs], thisDN, target);},\r\n            existsPrev(target :string | prevDN) :boolean{return localUtils.dno.existsPrev([DNs, sourceDNs, transDNs, exportDNs], thisDN, target)}\r\n        }\r\n    }\r\n    #detectDN(node :Element) :void{\r\n        if(node.textContent){\r\n            const sDNm = node.textContent.match(/^__[^:]+__$/),\r\n                  tDNm = node.textContent.match(/^--[^:]+--$/),\r\n                  eDNm = node.textContent.match(/^::[^:]+::$/);\r\n            //没有匹配到则为null，匹配到则[0]为::example::\r\n            if(eDNm) this.exportDN({\r\n                name: eDNm[0].substring(2, eDNm[0].length - 2),\r\n                methods: {}, //其实可以不用，utils那边做了兜底\r\n                export(data :any) :any{\r\n                    node.textContent = Object.prototype.toString.call((this as anyObject).value); //这里的this是精心设计的\r\n                }\r\n            });\r\n            /*else if(tDNm) this.transDN({\r\n\r\n            });\r\n            else if(sDNm) this.sourceDN({\r\n\r\n            });*/\r\n        }\r\n        const attrs = node.attributes;\r\n        //别写in，否则出一大堆方法\r\n        //NameNodeMap可以用数组那套，NameNodeMap.length返回的是正确的长度\r\n        for(let i = 0; i < attrs.length; i++){\r\n            //todo:检查属性\r\n\r\n        }\r\n        //遍历DOM，递归\r\n        for(let i = 0; i < node.childNodes.length; i++){\r\n\r\n        }\r\n    }\r\n}\r\n\r\n\r\n//对象导出\r\nutils.generic.constantize(Dynamic);\r\nexport default Dynamic;","/* utils\r\n * ©2022 LJM12914. https://github.com/wheelsmake/utils\r\n * Licensed under MIT License. https://github.com/wheelsmake/utils/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"./index\";\r\n/**一定会返回Element，void为报错hack*/\r\nexport function reduceToElement(input :Elementy) :Element | void{\r\n    if(input instanceof Element) return input;\r\n    else if(typeof input == \"string\"){\r\n        const el = utils.element.e(input);\r\n        if(el instanceof Node) return el as Element;\r\n        else utils.generic.E(\"rootNode\", \"string | Element\", input, \"rootNode should be a VALID #id selector\"); //fixed:现在不会走到new Element()那儿了\r\n    }\r\n    else utils.generic.E(\"rootNode\", \"string | Element\", input, \"rootNode should be a #id selector or an Element\");\r\n}","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport Dynamic from \"./dynamic\";\r\n//fixed:当作模块使用的时候不需要弄到全局作用域，所以将这个东西抽出来了\r\nObject.defineProperty(window, \"Dynamic\", {\r\n    configurable: false,\r\n    writable: false,\r\n    enumerable: true,\r\n    value: Dynamic\r\n});"],"names":["e","s","scope","undefined","Element","document","a","querySelectorAll","length","match","Array","from","precisePop","ele","array","indexOf","splice","E","argument","type","value","reason","Error","EE","message","checkArgs","args","b","c","methods","fetch","frequency","export","connectTo","data","objective","target","targetDN","processTarget","nexts","push","prevs","disconnectTo","existsPrev","existsNext","i","name","DEV","window","Dynamic","constructor","rootNode","this","input","el","Node","__DEV__getPrivateFields__","sourceDNs","transDNs","exportDNs","DNs","sourceDN","thisDN","result","freq","transDN","get","set","result2","connectFrom","disconnectFrom","Object","defineProperty","configurable","enumerable","exportDN","node","textContent","eDNm","substring","prototype","toString","call","attrs","attributes","childNodes","constantize","obj","freeze","keys","writable"],"sourceRoot":""}